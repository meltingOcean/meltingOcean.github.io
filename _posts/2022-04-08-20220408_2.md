---
title:  "캔들차트 분석 - 분류"
permalink: /posts/:title/
last_modified_at: 2022-04-08T16:23:00+09:00
---

주가데이터를 이용해 캔들차트를 생성하고 이진분류기를 이용해 일일 주가의 등락을 예측한다.
주가의 등락을 단순하게 0, 1 로만 레이블링한다.

S0. 종목 선택
 - KOSPI200 의 시가총액 1위인 삼성전자 주식

 S1. 데이터 찾기
 - FinanceDataReader를 통해 불러온 일일 주가데이터를 사용한다.
 
불러온 데이터를 디렉토리를 따로 지정하여 저장한다.
---
    def removeOutput(filepath):
        if(Path(filepath)).is_file():
            os.remove(filepath)
        
    def csv_initiator(market, ticker, head_date, tail_date):
        df = fdr.DataReader(ticker, head_date, tail_date, exchange=market)
        
        filedir = os.getcwd() + '\\dataset\\raw_data\\'
        filename = "{}_{}.csv".format(market, ticker)    
        filepath = filedir + filename
        
        if not os.path.exists(filedir):
            os.makedirs(filedir)    
        removeOutput(filepath)
        df.to_csv(filepath)
        
        print("csv file saved as : {}".format(filepath))
        
        return filepath
---

 S2. 데이터 전처리
 - labeld data 생성

기간이 일정부분 중복되며 연속된 캔들차트들이 데이터가 분류 대상이 된다.
기간은 일단은 임의대로 설정하며 기간의 어떤 기간으로 설정했을때 좋은 결과가 나오는지도 중요한 포인트가 될 것이다.
아래는 캔들차트데이터와 해당 캔들차트데이터에는 어떻게 레이블링 해야하는지 설명된 그림이다.
---
<p align="center"><img src="{{site.url}}/assets/images/labeling.jpg"></p>
---

레이블링하는 코드는 다음과 같다.
---
    def seqEnd_trend(csv_path, seq_len):
        print("Creating label . . .")
        print("type : sequence_end")
        
        # 데이터프레임으로 일일주가데이터 불러오기, 결측치 제거
        df = pd.read_csv(csv_path, parse_dates=True, index_col=0)
        df.fillna(0)
        df.reset_index(inplace=True)
        df['Date'] = df['Date'].map(mdates.date2num) # Y-M-D 포멧에서 num 포멧으로 변경
            
        # 파일을 저장할 디렉토리 명과 파일이름 지정
        filedir = os.getcwd() + '\\dataset\\labeled_data\\'
        filename = "{}_label_seq{}.txt".format(csv_path.split('\\')[-1][0:-4], seq_len) # ex) KRX_005930_label_seq30 
        filepath = filedir + filename
            
        # 디렉토리가 없을시 생성, 같은이름의 파일 제거
        if not os.path.exists(filedir):
            os.makedirs(filedir)
        removeOutput(filepath)

        # 레이블링
        for i in range(0, len(df)-int(seq_len)-1):
            tmp_df = df.iloc[i:i + int(seq_len)+1]  # seq_len+1 만큼 데이터프레임 슬라이싱
            starting = int(tmp_df["Close"].iloc[-2]) # seq 마지막날 종가
            endvalue = int(tmp_df["Close"].iloc[-1]) # seq 다음날 종가
            tmp_rtn = endvalue / starting - 1 
            
            if tmp_rtn > 0:
                label = 1
            else:
                label = 0
            # 레이블링한 sequence를 한 라인으로 파일에 입력        
            with open(filepath, 'a') as the_file:
                the_file.write("{}--{},{}".format(filename[0:-4], i, label))
                the_file.write("\n")

        print("Create label finished.")
        return filepath
---

 - 캔들차트 생성
 mpl_finance의 candlstick2_ochl 함수를 이용해서 순차적으로 캔들차트를 생성한다.

---
    def ohlc2cs(csv_path, seq_len, dimension, use_volume):
        print("Converting ohlc to candlestick")

        # 데이터프레임으로 일일주가데이터 불러오기, 결측치 제거
        df = pd.read_csv(csv_path, parse_dates=True, index_col=0)
        df.fillna(0)
        df.reset_index(inplace=True)
        df['Date'] = df['Date'].map(mdates.date2num) # Y-M-D 포멧에서 num 포멧으로 변경
        
        # 파일을 저장할 디렉토리 명과 파일이름 지정
        symbol = csv_path.split('\\')[-1][0:-4]
        filedir = os.getcwd() + '\\dataset\\candle_chart\\{}\\seq{}_dim{}_vol{}\\'.format(
                                    symbol, seq_len, dimension, use_volume) # ex) seq30_dim536_volFalse
        
        # 디렉토리가 없을시 생성, 이미 디렉토리가 있다면 내용물 삭제하고 다시 생성
        if not os.path.exists(filedir):
            os.makedirs(filedir)
        else:
            shutil.rmtree(filedir)
            os.makedirs(filedir)
        
        plt.style.use('dark_background') # 배경을 검은색으로
        
        for i in range(0, len(df)-int(seq_len)-1):
            tmp_df = df.iloc[i:i + int(seq_len)]
            if len(tmp_df) == int(seq_len):
                my_dpi = 109 # 자신의 모니터에 맞는 dpi 설정 27inch qhd -> 109
                fig = plt.figure(figsize=(dimension / my_dpi, dimension / my_dpi), dpi=my_dpi) # figure size 설정
                ax1 = fig.add_subplot(1, 1, 1)
                
                # Open, Close, High, Low column을 arguments로 넘겨준다.
                candlestick2_ochl(ax1, tmp_df['Open'], tmp_df['Close'], tmp_df['High'], tmp_df['Low'],
                                    width=1, colorup='#ed3738', colordown='#0a7df3')
                
                # 학습에 필요한 부분만 남도록 정리
                ax1.grid(False)
                ax1.set_xticklabels([])
                ax1.set_yticklabels([])
                ax1.xaxis.set_visible(False)
                ax1.yaxis.set_visible(False)
                ax1.axis('off')
                            
                if use_volume: # volume 정보를 사용할 경우에
                    ax2 = ax1.twinx()
                    bc = volume_overlay(ax2, tmp_df['Open'], tmp_df['Close'], tmp_df['Volume'],
                                            colorup='#ed3738', colordown='#0A7df3',
                                            alpha=0.5,  width=1)
                    ax2.add_collection(bc)
                    
                    # 학습에 필요한 부분만 남도록 정리
                    ax2.grid(False)
                    ax2.set_xticklabels([])
                    ax2.set_yticklabels([])
                    ax2.xaxis.set_visible(False)
                    ax2.yaxis.set_visible(False)
                    ax2.axis('off')
                
                filename = '{}-{}'.format(symbol, i)
                filepath = filedir + filename
                fig.savefig(filepath, pad_inches=0, transparent=False)
                plt.close(fig)
                
        print("Converting ohlc to candlestick finished")
---

위 함수들의 실행은 다음과 같이 메인코드를 작성한다.
데이터불러오기 - 데이터 전처리, 레이블링 - 캔들차트생성 까지의 과정을 실행한다.

---
    # main
    market = 'KRX'
    ticker = '005930'
    seq_len = '20'
    head_date = '2000-01-01'
    tail_date = '2022-01-01'
    dimension = 109
    use_volume = False

    data_csv_path = csv_initiator(market, ticker, head_date, tail_date)
    label_set_path = seqEnd_trend(data_csv_path, seq_len)
    candlechart_dir = ohlc2cs(data_csv_path, seq_len, dimension, use_volume)
---

이제 머신러닝 모델을선택하여서 적용시켜야한다.
이번에 선택할 모델은 sklearn에 있는 classifier 몇가지를 사용하고, gridsearchCV를 이용해서
하이퍼파라미터를 튜닝 할 것이다.

모델에 적용시키기전에 만들어둔 레이블데이터와 캔들차트 데이터들을 데이터어레이로 전환해야한다.

---
    # 캔들차트이미지를 데이터 셋으로
    # 한 픽셀의 RGB 값, 한 변의 픽셀 수는 dimension
    def image2dataarray(candlechart_dir):
        symbol = candlechart_dir.split('\\')[-3]
        imgs = list([])
        for i in range(len(os.listdir(candlechart_dir))):
            imgname = '{}-{}.png'.format(symbol, i)
            im = Image.open(candlechart_dir+imgname)
            pixels = list(im.getdata())
            img = list([])
            for pixel in pixels:
                for j in range(3): # Excepting alpha value
                    img.append(pixel[j])
            imgs.append(img)
            # print(imgs)
        return np.array(imgs)

    def label2dataarray(label_set_path):
        label_array = list([])
        with open(label_set_path, 'r') as f:
            lines = f.readlines()
            for line in lines:
                label = int(line.split(',')[-1])
                label_array.append(label)
            return np.array(label_array)
---
    candle_array = image2dataarray(candlechart_dir)
    label_array = label2dataarray(label_set_path)
    print(len(candle_array), len(label_array))
---
    Img(candlechart_dir + os.listdir(candlechart_dir)[1], height=109, width=190) # 생성된 캔들차트 샘플확인
---

전체세트의 앞 90퍼센트를 train 세트, 나머지를 test 셋으로 사용하기로 한다.

---
    X_all = candle_array
    y_all = label_array

    slicer = int(0.9 * len(candle_array)) # 임의로 train-test 분리

    X_train, ytrain = X_all[:slicer], y_all[:slicer]
    X_test, y_test = X_all[slicer:], y_all[slicer:]
---


첫번째로 사용할 분류기는 사이킷런의 SGDClassifier이다.
gridserchCV 로 train_set에 교차검증을 하면서 최적의 파라미터를 찾아야하는데 많은 종류의 파라미터를
시간이 걸린다. 병렬 연산이 가능하긴 하지만 워낙 파라미터 수가 많고 사이킷런에서는 gpu를 이용한 연산이 불가능
하기 때문에 CPU만으로는 많은 양의 연산을 하기 힘들다. 따라서 연산시간을 줄이기 위해서 여러가지 방법을 사용하기 로 했다.

1. 데이터셋 크기 줄이기
 - mpl_finance의 candlestick2_ochl() 넘겨받은 데이터를 가지고 설정한 width를 가진 캔들차트를 생성한다.
 픽셀수가 많을수록 연산시간이 늘어나므로 특성은 변하지 않으면서도 픽셀의 수를 줄이는 방법이 필요하다. 하지만 픽셀수를 너무 줄이면 캔들차트가 정상적인 모습을 가지지 않고 뭉게지는 현상이 발생한다. 단위 시퀀스의 길이와 캔들 하나의 width를 적절하게 설정해야만 깔끔하고 일정한 모양의 캔들차트가 만들어진다고 생각했고 적절한 크기가 얼마인지에 대해서 여러 시도를 해 보았다.

  - 연속된 두 캔들의 겹침 : 시퀀스는 길고 width의 크기는 크고 figure의 사이즈는 작으면 연속된 캔들끼리 겹치게된다.

|seq_len=20 width=1 1inch * 1inch, dpi = 109|  seq_len = 10width=0.5 1inch * 1inch, dpi = 109|
|:-:|:-:|
|![20]({{site.url}}/assets/images/overlaped_candle.png)|![10]({{site.url}}/assets/images/non-overlaped_candle.png)|
